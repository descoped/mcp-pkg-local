# Testing Guide

## Test Structure

The test suite is organized into categories for efficient execution and CI optimization:

### Test Categories

#### Unit Tests (`tests/unit/`)
- **Speed**: ⚡ Fast (~5 seconds)
- **Purpose**: Test individual functions and modules in isolation
- **Coverage**: AST extraction, package reading, groups, cache
- **Run**: `npm run test:unit`

#### Bottles Tests (`tests/bottles/`)
- **Speed**: ⚡ Fast (~10 seconds)
- **Purpose**: Test Bottles architecture components
- **Coverage**: Shell-RPC, Volume Controller, Package Manager adapters
- **Run**: `npm run test:bottles`

#### Integration Tests (`tests/integration/`)
- **Speed**: 🐢 Slow (~30 seconds)
- **Purpose**: Test full workflows with real environments
- **Coverage**: Python/Node.js integration, unified schema, performance features
- **Run**: `npm run test:integration`

#### Bottles Integration Tests (`tests/bottles/integration/`)
- **Speed**: 🐢 Slow (~45 seconds)
- **Purpose**: Test Bottles with real package managers
- **Coverage**: pip/uv installations, cache persistence, cross-adapter compatibility
- **Run**: `npm run test:bottles:integration`

#### Performance Tests (`tests/performance/`)
- **Speed**: ⚡ Fast (~5 seconds)
- **Purpose**: Benchmark critical operations
- **Coverage**: Cache performance, SQLite operations
- **Run**: `npm run test:performance`

## Running Tests

### Quick Commands

```bash
# Run all tests
npm test

# Run specific categories
npm run test:unit                  # Unit tests only
npm run test:integration           # Integration tests only
npm run test:bottles               # Bottles unit tests only
npm run test:bottles:integration   # Bottles integration tests only
npm run test:performance           # Performance benchmarks only

# Speed-based grouping
npm run test:fast    # All fast tests (unit + bottles)
npm run test:slow    # All slow tests (integration + bottles integration + performance)

# CI stages (used by GitHub Actions)
npm run test:ci:stage1   # Unit tests
npm run test:ci:stage2   # Bottles tests
npm run test:ci:stage3   # Integration tests
npm run test:ci:stage4   # Bottles integration tests
npm run test:ci:stage5   # Performance tests
```

### Test Development

```bash
# Watch mode for development
npm run test:ui

# Coverage report
npm run test:coverage
```

## CI Pipeline

The CI pipeline runs tests in stages for faster feedback:

### Stage 1: Quick Checks & Unit Tests
- ✅ Linting
- ✅ Type checking
- ✅ Build verification
- ✅ Unit tests
- **Fail fast**: Stops pipeline if basics fail

### Stage 2: Bottles Tests
- ✅ Shell-RPC tests
- ✅ Volume Controller tests
- ✅ Package Manager adapter tests
- **Runs in parallel** with Stage 3

### Stage 3: Integration Tests
- ✅ Python environment tests
- ✅ Node.js environment tests
- ✅ Unified schema tests
- **Runs in parallel** with Stage 2

### Stage 4: Bottles Integration Tests
- ✅ Real pip installations
- ✅ Real uv installations
- ✅ Cache persistence tests
- **Depends on**: Stage 2 success

### Stage 5: Performance Tests
- ✅ Cache benchmarks
- ✅ SQLite performance
- **Optional**: Doesn't fail the build

## Manual Testing

Use the workflow dispatch for selective testing:

1. Go to GitHub Actions
2. Select "Selective Tests" workflow
3. Choose test type:
   - `all` - Run complete test suite
   - `unit` - Unit tests only
   - `integration` - Integration tests only
   - `bottles` - Bottles unit tests only
   - `bottles-integration` - Bottles integration tests only
   - `performance` - Performance tests only
   - `fast` - All fast tests
   - `slow` - All slow tests

## Timeout Configuration

Tests use configurable timeouts that adapt to the environment:

- **Local**: Default timeouts (5s, 15s, 30s)
- **CI**: 1.5x multiplier for reliability
- **Custom**: Set `PKG_LOCAL_TIMEOUT_MULTIPLIER` environment variable

### Activity-Based Timeouts

Package manager operations use activity-based timeouts:
- Timeout resets on stdout activity (progress indicators)
- Stderr output does NOT reset timeout (prevents hanging on errors)
- Maximum timeout: 30 seconds

## Debugging Failed Tests

### Local Debugging

```bash
# Keep test directories on failure
export PRESERVE_TEST_DIRS_ON_FAILURE=true
npm test

# Enable debug logging
export DEBUG=mcp-pkg-local:*
npm test

# Run specific test file
npx vitest run tests/unit/ast-extraction.test.ts

# Run tests matching pattern
npx vitest run -t "should handle timeout"
```

### CI Debugging

Failed CI runs provide:
- Test output with error details
- Stage that failed (quick feedback)
- Artifacts (if configured)

## Best Practices

1. **Write fast unit tests** - They run first and provide quick feedback
2. **Use appropriate timeouts** - Import from `tests/config/timeouts.ts`
3. **Clean up resources** - Use `afterEach` hooks for cleanup
4. **Test categories** - Place tests in appropriate directories
5. **Mock when possible** - Especially for slow operations in unit tests
6. **Use test utilities** - Import from `tests/bottles/integration/test-utils.ts`

## Adding New Tests

1. Determine the category (unit, integration, bottles, performance)
2. Create test file in appropriate directory
3. Import timeout configuration:
   ```typescript
   import { TIMEOUTS } from '../config/timeouts.js';
   ```
4. Use appropriate timeout:
   ```typescript
   it('should do something', async () => {
     // test code
   }, TIMEOUTS.medium);
   ```