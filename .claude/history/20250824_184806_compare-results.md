# Enhanced npm Package Analysis - AI Implementation Instructions

## Objective
Implement enhanced npm package analysis that provides the same level of detail as Python/venv packages, including full source code extraction with classes, functions, and other exported symbols.

## Current State vs Desired State

### Current npm Package Output (Limited)
The current npm `read-package` operation only returns basic metadata:

```json
{
  "type": "tree",
  "success": true,
  "package": "@modelcontextprotocol/sdk",
  "version": "1.17.3",
  "initContent": "{\n  \"name\": \"@modelcontextprotocol/sdk\",\n  \"version\": \"1.17.3\",\n  \"description\": \"Model Context Protocol implementation for TypeScript\",\n  \"license\": \"MIT\",\n  \"author\": \"Anthropic, PBC (https://anthropic.com)\",\n  \"homepage\": \"https://modelcontextprotocol.io\",\n  \"bugs\": \"https://github.com/modelcontextprotocol/typescript-sdk/issues\",\n  \"type\": \"module\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/modelcontextprotocol/typescript-sdk.git\"\n  },\n  \"engines\": {\n    \"node\": \">=18\"\n  },\n  \"keywords\": [\n    \"modelcontextprotocol\",\n    \"mcp\"\n  ],\n  \"exports\": {\n    \".\": {\n      \"import\": \"./dist/esm/index.js\",\n      \"require\": \"./dist/cjs/index.js\"\n    },\n    \"./client\": {\n      \"import\": \"./dist/esm/client/index.js\",\n      \"require\": \"./dist/cjs/client/index.js\"\n    },\n    \"./server\": {\n      \"import\": \"./dist/esm/server/index.js\",\n      \"require\": \"./dist/cjs/server/index.js\"\n    },\n    \"./*\": {\n      \"import\": \"./dist/esm/*\",\n      \"require\": \"./dist/cjs/*\"\n    }\n  },\n  \"typesVersions\": {\n    \"*\": {\n      \"*\": [\n        \"./dist/esm/*\"\n      ]\n    }\n  },\n  \"files\": [\n    \"dist\"\n  ],\n  \"scripts\": {\n    \"fetch:spec-types\": \"curl -o spec.types.ts https://raw.githubusercontent.com/modelcontextprotocol/modelcontextprotocol/refs/heads/main/schema/draft/schema.ts\",\n    \"build\": \"npm run build:esm && npm run build:cjs\",\n    \"build:esm\": \"mkdir -p dist/esm && echo '{\\\"type\\\": \\\"module\\\"}' > dist/esm/package.json && tsc -p tsconfig.prod.json\",\n    \"build:esm:w\": \"npm run build:esm -- -w\",\n    \"build:cjs\": \"mkdir -p dist/cjs && echo '{\\\"type\\\": \\\"commonjs\\\"}' > dist/cjs/package.json && tsc -p tsconfig.cjs.json\",\n    \"build:cjs:w\": \"npm run build:cjs -- -w\",\n    \"examples:simple-server:w\": \"tsx --watch src/examples/server/simpleStreamableHttp.ts --oauth\",\n    \"prepack\": \"npm run build:esm && npm run build:cjs\",\n    \"lint\": \"eslint src/\",\n    \"test\": \"npm run fetch:spec-types && jest\",\n    \"start\": \"npm run server\",\n    \"server\": \"tsx watch --clear-screen=false src/cli.ts server\",\n    \"client\": \"tsx src/cli.ts client\"\n  },\n  \"dependencies\": {\n    \"ajv\": \"^6.12.6\",\n    \"content-type\": \"^1.0.5\",\n    \"cors\": \"^2.8.5\",\n    \"cross-spawn\": \"^7.0.5\",\n    \"eventsource\": \"^3.0.2\",\n    \"eventsource-parser\": \"^3.0.0\",\n    \"express\": \"^5.0.1\",\n    \"express-rate-limit\": \"^7.5.0\",\n    \"pkce-challenge\": \"^5.0.0\",\n    \"raw-body\": \"^3.0.0\",\n    \"zod\": \"^3.23.8\",\n    \"zod-to-json-schema\": \"^3.24.1\"\n  },\n  \"devDependencies\": {\n    \"@eslint/js\": \"^9.8.0\",\n    \"@jest-mock/express\": \"^3.0.0\",\n    \"@types/content-type\": \"^1.1.8\",\n    \"@types/cors\": \"^2.8.17\",\n    \"@types/cross-spawn\": \"^6.0.6\",\n    \"@types/eslint__js\": \"^8.42.3\",\n    \"@types/eventsource\": \"^1.1.15\",\n    \"@types/express\": \"^5.0.0\",\n    \"@types/jest\": \"^29.5.12\",\n    \"@types/node\": \"^22.0.2\",\n    \"@types/supertest\": \"^6.0.2\",\n    \"@types/ws\": \"^8.5.12\",\n    \"eslint\": \"^9.8.0\",\n    \"jest\": \"^29.7.0\",\n    \"supertest\": \"^7.0.0\",\n    \"ts-jest\": \"^29.2.4\",\n    \"tsx\": \"^4.16.5\",\n    \"typescript\": \"^5.5.4\",\n    \"typescript-eslint\": \"^8.0.0\",\n    \"ws\": \"^8.18.0\"\n  },\n  \"resolutions\": {\n    \"strip-ansi\": \"6.0.1\"\n  }\n}",
  "fileTree": [
    "package.json"
  ],
  "fileCount": 2,
  "mainFiles": [
    "package.json"
  ]
}
```

### Desired npm Package Output (Rich Content Like Python)
The npm package should return detailed source code like Python packages do. See Python example below for reference format.

## Implementation Requirements

### 1. Source Code Extraction
When processing npm packages, the tool must:
- Parse JavaScript/TypeScript files to extract:
  - Exported functions and their signatures
  - Classes and their methods
  - Constants and exported variables
  - Type definitions/interfaces (for TypeScript)
- Include the actual source code content, similar to Python packages

### 2. Test Case Verbose Logging
- Add verbose logging to test cases using a feature flag/environment variable
- When enabled in tests, log:
  - Raw output from `scan-packages` operation
  - Raw output from `read-package` operation
  - Parsed content structure
- This helps visually verify the generated content during test development

## Example: Python Package Output (Target Format)

```json
{
  "type": "file",
  "success": true,
  "package": "fastapi-testing",
  "filePath": "async_fastapi_testing.py",
  "content": "import asyncio\nimport json\nimport logging\nimport os\nfrom collections.abc import AsyncGenerator\nfrom contextlib import asynccontextmanager, suppress\nfrom dataclasses import dataclass\nfrom typing import Any\n\nimport httpx\nimport uvicorn\nfrom fastapi import FastAPI\nfrom fastapi.applications import AppType\nfrom starlette.types import Lifespan\nfrom websockets.asyncio.client import ClientConnection, connect\nfrom websockets.protocol import State\n\nlogger = logging.getLogger(__name__)\n\n# Configuration Constants\nDEFAULT_WS_MESSAGE_SIZE = 2**20  # 1MB\nDEFAULT_WS_QUEUE_SIZE = 32\nDEFAULT_KEEPALIVE_CONNS = 20\nDEFAULT_MAX_CONNS = 100\nDEFAULT_WS_RETRY_ATTEMPTS = 3\nDEFAULT_WS_RETRY_DELAY = 1.0\n\n\nclass Config:\n    \"\"\"\n    Global configuration settings for fastapi-testing framework.\n    \"\"\"\n\n    def __init__(\n        self,\n        ws_max_message_size: int = DEFAULT_WS_MESSAGE_SIZE,\n        ws_max_queue_size: int = DEFAULT_WS_QUEUE_SIZE,\n        http_max_keepalive: int = DEFAULT_KEEPALIVE_CONNS,\n        http_max_connections: int = DEFAULT_MAX_CONNS,\n        ws_retry_attempts: int = DEFAULT_WS_RETRY_ATTEMPTS,\n        ws_retry_delay: float = DEFAULT_WS_RETRY_DELAY,\n        port_range_start: int = 8001,\n        port_range_end: int = 9000,\n    ):\n        self.WS_MAX_MESSAGE_SIZE = ws_max_message_size\n        self.WS_MAX_QUEUE_SIZE = ws_max_queue_size\n        self.HTTP_MAX_KEEPALIVE = http_max_keepalive\n        self.HTTP_MAX_CONNECTIONS = http_max_connections\n        self.WS_RETRY_ATTEMPTS = ws_retry_attempts\n        self.WS_RETRY_DELAY = ws_retry_delay\n        self.PORT_RANGE_START = port_range_start\n        self.PORT_RANGE_END = port_range_end\n\n    @classmethod\n    def from_env(cls, prefix: str = \"FASTAPI_TESTING_\"):\n        \"\"\"\n        Create configuration from environment variables.\n        This is an explicit opt-in method.\n        \"\"\"\n        # Only look for variables with the specified prefix\n        env_vars = {k: v for k, v in os.environ.items() if k.startswith(prefix)}\n\n        # Convert to expected parameter names\n        config_params = {}\n        for env_key, env_value in env_vars.items():\n            config_key = env_key[len(prefix) :].lower()\n            # Handle type conversion\n            if config_key in [\n                \"ws_max_message_size\",\n                \"ws_max_queue_size\",\n                \"http_max_keepalive\",\n                \"http_max_connections\",\n                \"ws_retry_attempts\",\n                \"port_range_start\",\n                \"port_range_end\",\n            ]:\n                with suppress(ValueError):\n                    config_params[config_key] = int(env_value)\n            elif config_key == \"ws_retry_delay\":\n                with suppress(ValueError):\n                    config_params[config_key] = float(env_value)\n\n        return cls(**config_params)\n\n    @classmethod\n    def from_file(cls, file_path: str):\n        \"\"\"Load configuration from a file.\"\"\"\n        # Implementation for loading from a file (JSON, YAML, etc.)\n        pass\n\n\n# Create the global configuration with defaults\nglobal_config = Config()\n\n\n# Users can override it with their own configuration:\n# global_config = Config.from_env()\n# or\n# global_config = Config(ws_max_message_size=2**21, http_max_connections=200)\n\n\nclass InvalidResponseTypeError(Exception):\n    \"\"\"Exception raised when an operation is not supported for the response type.\"\"\"\n\n    pass\n\n\n@dataclass\nclass WebSocketConfig:\n    \"\"\"WebSocket connection configuration.\n\n    Attributes:\n        subprotocols: List of supported subprotocols\n        compression: Compression algorithm to use\n        extra_headers: Additional headers for the connection\n        ping_interval: Interval between ping messages\n        ping_timeout: Timeout for ping responses\n        max_size: Maximum message size in bytes\n        max_queue: Maximum number of queued messages\n        timeout: Connection timeout in seconds\n    \"\"\"\n\n    subprotocols: list[str] | None = None\n    compression: str | None = None\n    extra_headers: dict[str, str] | None = None\n    ping_interval: float | None = None\n    ping_timeout: float | None = None\n    max_size: int = global_config.WS_MAX_MESSAGE_SIZE\n    max_queue: int = global_config.WS_MAX_QUEUE_SIZE\n    timeout: float | None = None\n\n\nclass PortGenerator:\n    \"\"\"Manages port allocation for test servers using configuration from global settings.\"\"\"\n\n    def __init__(self, start: int | None = None, end: int | None = None):\n        if start is None:\n            start = global_config.PORT_RANGE_START\n        if end is None:\n            end = global_config.PORT_RANGE_END\n        self.start = start\n        self.end = end\n        self.used_ports: set[int] = set()\n\n    @staticmethod\n    def is_port_available(port: int) -> bool:\n        import socket\n        from contextlib import closing\n\n        with closing(socket.socket(socket.AF_INET, socket.SOCK_STREAM)) as sock:\n            try:\n                sock.bind((\"localhost\", port))\n                return True\n            except (OSError, OverflowError):\n                return False\n\n    def get_port(self) -> int:\n        \"\"\"Get an available port from the pool.\"\"\"\n        available_ports = set(range(self.start, self.end + 1)) - self.used_ports\n        if not available_ports:\n            raise RuntimeError(f\"No available ports in range {self.start}-{self.end}\")\n\n        import random\n\n        while available_ports:\n            port = random.choice(list(available_ports))\n            if self.is_port_available(port):\n                self.used_ports.add(port)\n                return port\n            available_ports.remove(port)\n        raise RuntimeError(f\"No available ports found in range {self.start}-{self.end}\")\n\n    def release_port(self, port: int) -> None:\n        \"\"\"Release a port back to the pool.\"\"\"\n        self.used_ports.discard(port)\n\n\nclass AsyncTestResponse:\n    \"\"\"Enhanced response wrapper supporting both HTTP and WebSocket responses.\n\n    Provides unified interface for handling both HTTP and WebSocket responses\n    with proper type checking and error handling.\n    \"\"\"\n\n    def __init__(self, response: httpx.Response | ClientConnection):\n        self._response = response\n        self._is_websocket = isinstance(response, ClientConnection)\n\n    async def json(self) -> Any:\n        \"\"\"Get JSON response (HTTP only).\"\"\"\n        if self._is_websocket:\n            raise InvalidResponseTypeError(\n                \"Cannot get JSON directly from WebSocket response. Use websocket() methods instead.\"\n            )\n        return await asyncio.to_thread(self._response.json)\n\n    async def text(self) -> str:\n        \"\"\"Get text response (HTTP only).\"\"\"\n        if self._is_websocket:\n            raise InvalidResponseTypeError(\n                \"Cannot get text directly from WebSocket response. Use websocket() methods instead.\"\n            )\n        return await asyncio.to_thread(lambda: self._response.text)\n\n    @property\n    def status_code(self) -> int:\n        \"\"\"Get status code (HTTP only).\"\"\"\n        if self._is_websocket:\n            raise InvalidResponseTypeError(\"WebSocket connections don't have status codes\")\n        return self._response.status_code\n\n    @property\n    def headers(self) -> httpx.Headers:\n        \"\"\"Get response headers (HTTP only).\"\"\"\n        if self._is_websocket:\n            raise InvalidResponseTypeError(\"WebSocket connections don't have headers\")\n        return self._response.headers\n\n    def websocket(self) -> ClientConnection:\n        \"\"\"Get WebSocket connection (WebSocket only).\"\"\"\n        if not self._is_websocket:\n            raise InvalidResponseTypeError(\"This response is not a WebSocket connection\")\n        return self._response\n\n    async def expect_status(self, status_code: int) -> \"AsyncTestResponse\":\n        \"\"\"Assert expected status code (HTTP only).\"\"\"\n        if self._is_websocket:\n            raise InvalidResponseTypeError(\"WebSocket connections don't have status codes\")\n        assert self._response.status_code == status_code, (\n            f\"Expected status {status_code}, got {self._response.status_code}\"\n        )\n        return self\n\n\nclass WebSocketHelper:\n    \"\"\"Helper methods for WebSocket operations.\"\"\"\n\n    @staticmethod\n    async def send_json(resp: AsyncTestResponse, data: Any) -> None:\n        \"\"\"Send JSON data over WebSocket.\"\"\"\n        ws = resp.websocket()\n        await ws.send(json.dumps(data))\n\n    @staticmethod\n    async def receive_json(resp: AsyncTestResponse) -> Any:\n        \"\"\"Receive JSON data from WebSocket.\"\"\"\n        ws = resp.websocket()\n        data = await ws.recv()\n        if not isinstance(data, str):\n            raise TypeError(f\"Expected text data to decode JSON, got {type(data)}\")\n        return json.loads(data)\n\n    @staticmethod\n    async def send_binary(resp: AsyncTestResponse, data: bytes) -> None:\n        \"\"\"Send binary data over WebSocket.\"\"\"\n        ws = resp.websocket()\n        await ws.send(data)\n\n    @staticmethod\n    async def receive_binary(resp: AsyncTestResponse) -> bytes:\n        \"\"\"Receive binary data from WebSocket.\"\"\"\n        ws = resp.websocket()\n        data = await ws.recv()\n        if not isinstance(data, bytes):\n            raise TypeError(f\"Expected bytes, got {type(data)}\")\n        return data\n\n    @staticmethod\n    async def send_text(resp: AsyncTestResponse, data: str) -> None:\n        \"\"\"Send text data over WebSocket.\"\"\"\n        ws = resp.websocket()\n        await ws.send(data)\n\n    @staticmethod\n    async def receive_text(resp: AsyncTestResponse) -> str:\n        \"\"\"Receive text data from WebSocket.\"\"\"\n        ws = resp.websocket()\n        data = await ws.recv()\n        if not isinstance(data, str):\n            raise TypeError(f\"Expected str, got {type(data)}\")\n        return data\n\n    @staticmethod\n    async def expect_message(\n        resp: AsyncTestResponse, expected: str | dict | bytes, timeout: float | None = None\n    ) -> None:\n        \"\"\"Assert expected message is received within timeout.\"\"\"\n        ws = resp.websocket()\n        try:\n            message = await asyncio.wait_for(ws.recv(), timeout)\n        except TimeoutError as e:\n            logger.error(\"Timed out waiting for message\")\n            raise e\n\n        if isinstance(expected, dict):\n            if not isinstance(message, str):\n                raise AssertionError(f\"Expected a text message for JSON decoding, got {type(message)}\")\n            if json.loads(message) != expected:\n                raise AssertionError(f\"Expected message {expected}, got {message}\")\n        else:\n            if message != expected:\n                raise AssertionError(f\"Expected message {expected}, got {message}\")\n\n    @staticmethod\n    async def drain_messages(resp: AsyncTestResponse, timeout: float | None = 0.1) -> list[Any]:\n        \"\"\"Drain all pending messages from websocket queue.\"\"\"\n        ws = resp.websocket()\n        messages = []\n        try:\n            while True:\n                message = await asyncio.wait_for(ws.recv(), timeout)\n                messages.append(message)\n        except TimeoutError:\n            pass\n        return messages\n\n\nclass AsyncTestClient:\n    \"\"\"Async test client supporting both HTTP and WebSocket connections.\"\"\"\n\n    def __init__(self, base_url: str, timeout: float = 30.0, follow_redirects: bool = True):\n        self._base_url = base_url.rstrip(\"/\")\n        self._timeout = timeout\n        self._websocket_connections: set[ClientConnection] = set()\n\n        limits = httpx.Limits(\n            max_keepalive_connections=global_config.HTTP_MAX_KEEPALIVE,\n            max_connections=global_config.HTTP_MAX_CONNECTIONS,\n        )\n        self._client = httpx.AsyncClient(\n            base_url=self._base_url, timeout=timeout, follow_redirects=follow_redirects, limits=limits, http2=True\n        )\n\n        self.ws = WebSocketHelper()\n\n    async def close(self) -> None:\n        \"\"\"Close all connections and cleanup resources.\"\"\"\n        # Clean up any active websocket connections\n        for ws in list(self._websocket_connections):\n            try:\n                if ws.state == State.CLOSED:\n                    self._websocket_connections.discard(ws)\n                else:\n                    await ws.close()\n                    self._websocket_connections.discard(ws)\n            except Exception as e:\n                logger.warning(f\"Error closing websocket connection: {e}\")\n        self._websocket_connections.clear()\n\n        if self._client:\n            await self._client.aclose()\n\n    async def request(self, method: str, url: str, **kwargs: Any) -> AsyncTestResponse:\n        \"\"\"Make HTTP request.\"\"\"\n        response = await self._client.request(method, url, **kwargs)\n        return AsyncTestResponse(response)\n\n    async def websocket(\n        self, path: str, config: WebSocketConfig | None = None, options: dict[str, Any] | None = None\n    ) -> AsyncTestResponse:\n        \"\"\"Create a websocket connection with configuration.\"\"\"\n        if not (self._base_url.startswith(\"http://\") or self._base_url.startswith(\"https://\")):\n            raise ValueError(\"Invalid base URL. Must start with 'http://' or 'https://'\")\n        if self._base_url.startswith(\"https://\"):\n            ws_url = f\"wss://{self._base_url.replace('https://', '')}{path}\"\n        elif self._base_url.startswith(\"http://\"):\n            ws_url = f\"ws://{self._base_url.replace('http://', '')}{path}\"\n        else:\n            ws_url = f\"ws://{self._base_url}{path}\"\n\n        connect_kwargs: dict[str, Any] = {\n            \"open_timeout\": self._timeout,\n            \"max_size\": global_config.WS_MAX_MESSAGE_SIZE,\n            \"max_queue\": global_config.WS_MAX_QUEUE_SIZE,\n        }\n\n        if config:\n            if config.subprotocols:\n                connect_kwargs[\"subprotocols\"] = config.subprotocols\n            if config.compression:\n                connect_kwargs[\"compression\"] = config.compression\n            if config.extra_headers:\n                connect_kwargs[\"additional_headers\"] = config.extra_headers\n            if config.ping_interval:\n                connect_kwargs[\"ping_interval\"] = config.ping_interval\n            if config.ping_timeout:\n                connect_kwargs[\"ping_timeout\"] = config.ping_timeout\n            if config.timeout:\n                connect_kwargs[\"open_timeout\"] = config.timeout\n\n        if options:\n            connect_kwargs.update(options)\n\n        # Retry logic for establishing a WebSocket connection.\n        attempt = 0\n        while True:\n            try:\n                ws = await connect(ws_url, **connect_kwargs)\n                break\n            except Exception as e:\n                attempt += 1\n                if attempt >= global_config.WS_RETRY_ATTEMPTS:\n                    logger.error(\n                        f\"Failed to establish WebSocket connection after \"\n                        f\"{global_config.WS_RETRY_ATTEMPTS} attempts: {e}\"\n                    )\n                    raise\n                await asyncio.sleep(global_config.WS_RETRY_DELAY)\n\n        self._websocket_connections.add(ws)\n        return AsyncTestResponse(ws)\n\n    async def get(self, url: str, **kwargs: Any) -> AsyncTestResponse:\n        return await self.request(\"GET\", url, **kwargs)\n\n    async def post(self, url: str, **kwargs: Any) -> AsyncTestResponse:\n        return await self.request(\"POST\", url, **kwargs)\n\n    async def put(self, url: str, **kwargs: Any) -> AsyncTestResponse:\n        return await self.request(\"PUT\", url, **kwargs)\n\n    async def delete(self, url: str, **kwargs: Any) -> AsyncTestResponse:\n        return await self.request(\"DELETE\", url, **kwargs)\n\n    async def patch(self, url: str, **kwargs: Any) -> AsyncTestResponse:\n        return await self.request(\"PATCH\", url, **kwargs)\n\n    async def __aenter__(self) -> \"AsyncTestClient\":\n        return self\n\n    async def __aexit__(self, exc_type, exc, tb):\n        await self.close()\n\n\nclass UvicornTestServer(uvicorn.Server):\n    \"\"\"Uvicorn test server with startup event support.\"\"\"\n\n    def __init__(self, config: uvicorn.Config, startup_handler: asyncio.Event):\n        super().__init__(config)\n        self.startup_handler = startup_handler\n\n    async def startup(self, sockets: list | None = None) -> None:\n        \"\"\"Override startup to signal when ready.\"\"\"\n        await super().startup(sockets=sockets)\n        self.startup_handler.set()\n\n\n# Use the configurable PortGenerator instance\n_port_generator = PortGenerator()\n\n\nclass AsyncTestServer:\n    \"\"\"Async test server with proper lifecycle management and WebSocket support.\"\"\"\n\n    def __init__(\n        self,\n        lifespan: Lifespan[AppType] | None = None,\n        startup_timeout: float = 30.0,\n        shutdown_timeout: float = 10.0,\n    ):\n        self.app = FastAPI(lifespan=lifespan)\n        self.startup_timeout = startup_timeout\n        self.shutdown_timeout = shutdown_timeout\n        self._startup_complete = asyncio.Event()\n        self._shutdown_complete = asyncio.Event()\n        self._server_task: asyncio.Task | None = None\n        self._port: int | None = None\n        self._host = \"127.0.0.1\"\n        self._client: AsyncTestClient | None = None\n        self._server: UvicornTestServer | None = None\n        self._websocket_tasks: set[asyncio.Task] = set()\n\n    async def start(self) -> None:\n        \"\"\"Start the server asynchronously with proper lifecycle management.\"\"\"\n        if self._server_task is not None:\n            raise RuntimeError(\"Server is already running\")\n\n        self._port = _port_generator.get_port()\n        startup_handler = asyncio.Event()\n\n        config = uvicorn.Config(app=self.app, host=self._host, port=self._port, log_level=\"error\", loop=\"asyncio\")\n\n        self._server = UvicornTestServer(config=config, startup_handler=startup_handler)\n\n        self._server_task = asyncio.create_task(self._server.serve())\n\n        try:\n            await asyncio.wait_for(startup_handler.wait(), timeout=self.startup_timeout)\n\n            self._client = AsyncTestClient(base_url=self.base_url, timeout=self.startup_timeout)\n\n            self._startup_complete.set()\n\n        except (TimeoutError, Exception) as e:\n            await self.stop()\n            if isinstance(e, asyncio.TimeoutError):\n                raise RuntimeError(f\"Server startup timed out on host {self._host} and port {self._port}\") from e\n            raise\n\n    async def stop(self) -> None:\n        \"\"\"Stop the server and clean up all resources including WebSocket connections.\"\"\"\n        if not self._startup_complete.is_set():\n            return\n\n        # Cancel all WebSocket tasks\n        for task in self._websocket_tasks:\n            if not task.done():\n                task.cancel()\n        await asyncio.gather(*self._websocket_tasks, return_exceptions=True)\n        self._websocket_tasks.clear()\n\n        if self._client:\n            await self._client.close()\n            self._client = None\n\n        if self._server_task:\n            try:\n                if self._server:\n                    self._server.should_exit = True\n\n                await asyncio.wait_for(self._server_task, timeout=self.shutdown_timeout)\n\n            except TimeoutError:\n                logger.error(f\"Timeout waiting for server shutdown on host {self._host} port {self._port}\")\n                if not self._server_task.done():\n                    self._server_task.cancel()\n                    await asyncio.gather(self._server_task, return_exceptions=True)\n            except asyncio.CancelledError:\n                logger.info(\"Server task cancelled successfully\")\n            finally:\n                self._server_task = None\n\n        if self._port:\n            _port_generator.release_port(self._port)\n            self._port = None\n\n        self._shutdown_complete.set()\n\n    @property\n    def base_url(self) -> str:\n        if not self._port:\n            raise RuntimeError(\"Server is not running\")\n        return f\"http://{self._host}:{self._port}\"\n\n    async def __aenter__(self) -> \"AsyncTestServer\":\n        await self.start()\n        return self\n\n    async def __aexit__(self, exc_type: Any, exc_val: Any, exc_tb: Any) -> None:\n        await self.stop()\n\n    @property\n    def client(self) -> AsyncTestClient:\n        if not self._client:\n            raise RuntimeError(\"Server is not running\")\n        return self._client\n\n\n@asynccontextmanager\nasync def create_test_server(\n    lifespan: Lifespan[AppType] | None = None,\n) -> AsyncGenerator[AsyncTestServer, None]:\n    \"\"\"Create and manage a TestServer instance with proper lifecycle\"\"\"\n    server = AsyncTestServer(lifespan=lifespan)\n    try:\n        await server.start()\n        yield server\n    finally:\n        await server.stop()"
}
```

## Goal
npm packages should provide the same rich detail level as Python packages, with complete source code and all exported symbols visible in the `content` field.
