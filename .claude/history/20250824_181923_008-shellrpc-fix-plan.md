# Shell-RPC Layer Fix Implementation Plan

**Plan Number**: 4 of 4  
**Component**: Shell-RPC Layer  
**Priority**: üü¢ OPTIMIZATION  
**Estimated Impact**: 60-80% test runtime reduction  
**Risk Level**: Medium (affects all tests)  
**Timeline**: 3-4 days  
**Prerequisites**: Plans 1, 2, and 3 MUST be complete  
**Required by**: None (final optimization)

## Problem Statement

The Shell-RPC layer has four critical issues causing severe performance degradation:

1. **No connection pooling** - Each test creates new ShellRPC instance (100+ processes)
2. **No shell reuse** - Shell processes not shared between tests
3. **Synchronous tool detection** - `execSync` blocks event loop
4. **Memory leak potential** - Active timeouts Map not always cleaned

**‚ö†Ô∏è DEPENDENCIES**: This plan is the final optimization layer and requires:
- Plan 1: EnvironmentManager for centralized detection (no more execSync in adapters)
- Plan 2: BasePackageManagerAdapter for consistent shell usage patterns
- Plan 3: VolumeController properly initialized for cache environment variables

These issues result in:
- 500-1000ms overhead per test from shell initialization
- 100+ shell processes created during test suite
- Blocked event loop during tool detection
- Potential memory leaks from uncleaned timeout handlers

## Implementation Plan

### Phase 1: Shell-RPC Pool Implementation (Day 1)

#### 1.1 Create ShellRPCPool Class

**File**: `src/bottles/shell-rpc/pool.ts`

```typescript
/**
 * ShellRPC Pool for managing and reusing shell instances
 */
import { ShellRPC } from './index.js';
import type { ShellOptions } from './types.js';

export interface PoolOptions {
  maxSize?: number;           // Maximum pool size (default: 5)
  maxIdleTime?: number;        // Max idle time before cleanup (default: 60000ms)
  reuseStrategy?: 'lru' | 'fifo'; // Reuse strategy (default: 'lru')
}

export interface PooledShell {
  shell: ShellRPC;
  key: string;
  lastUsed: number;
  useCount: number;
  locked: boolean;
}

export class ShellRPCPool {
  private static instance: ShellRPCPool;
  private readonly pool = new Map<string, PooledShell>();
  private readonly options: Required<PoolOptions>;
  private cleanupInterval: NodeJS.Timeout | null = null;

  private constructor(options: PoolOptions = {}) {
    this.options = {
      maxSize: options.maxSize ?? 5,
      maxIdleTime: options.maxIdleTime ?? 60000,
      reuseStrategy: options.reuseStrategy ?? 'lru',
    };
    
    // Start cleanup interval
    this.startCleanupInterval();
  }

  static getInstance(options?: PoolOptions): ShellRPCPool {
    if (!ShellRPCPool.instance) {
      ShellRPCPool.instance = new ShellRPCPool(options);
    }
    return ShellRPCPool.instance;
  }

  /**
   * Acquire a shell from the pool or create new one
   */
  async acquire(key: string, options?: ShellOptions): Promise<ShellRPC> {
    // Try to get existing shell
    const existing = this.pool.get(key);
    if (existing && !existing.locked) {
      existing.locked = true;
      existing.lastUsed = Date.now();
      existing.useCount++;
      return existing.shell;
    }

    // Check if we need to evict old shells
    if (this.pool.size >= this.options.maxSize) {
      await this.evictLeastUsed();
    }

    // Create new shell
    const shell = new ShellRPC(options);
    await shell.initialize();

    const pooledShell: PooledShell = {
      shell,
      key,
      lastUsed: Date.now(),
      useCount: 1,
      locked: true,
    };

    this.pool.set(key, pooledShell);
    return shell;
  }

  /**
   * Release a shell back to the pool
   */
  release(key: string): void {
    const pooled = this.pool.get(key);
    if (pooled) {
      pooled.locked = false;
      pooled.lastUsed = Date.now();
    }
  }

  /**
   * Evict least recently used shell
   */
  private async evictLeastUsed(): Promise<void> {
    let leastUsed: PooledShell | null = null;
    let leastUsedKey: string | null = null;

    for (const [key, pooled] of this.pool.entries()) {
      if (!pooled.locked) {
        if (!leastUsed || pooled.lastUsed < leastUsed.lastUsed) {
          leastUsed = pooled;
          leastUsedKey = key;
        }
      }
    }

    if (leastUsedKey && leastUsed) {
      await leastUsed.shell.cleanup();
      this.pool.delete(leastUsedKey);
    }
  }

  /**
   * Start periodic cleanup of idle shells
   */
  private startCleanupInterval(): void {
    this.cleanupInterval = setInterval(() => {
      this.cleanupIdleShells();
    }, 10000); // Check every 10 seconds
  }

  /**
   * Clean up idle shells
   */
  private async cleanupIdleShells(): Promise<void> {
    const now = Date.now();
    const toDelete: string[] = [];

    for (const [key, pooled] of this.pool.entries()) {
      if (!pooled.locked && (now - pooled.lastUsed) > this.options.maxIdleTime) {
        toDelete.push(key);
      }
    }

    for (const key of toDelete) {
      const pooled = this.pool.get(key);
      if (pooled) {
        await pooled.shell.cleanup();
        this.pool.delete(key);
      }
    }
  }

  /**
   * Clear all shells from pool
   */
  async clear(): Promise<void> {
    const cleanupPromises: Promise<void>[] = [];
    
    for (const pooled of this.pool.values()) {
      cleanupPromises.push(pooled.shell.cleanup());
    }

    await Promise.all(cleanupPromises);
    this.pool.clear();

    if (this.cleanupInterval) {
      clearInterval(this.cleanupInterval);
      this.cleanupInterval = null;
    }
  }
  
  /**
   * Global cleanup for test suite
   */
  static async globalCleanup(): Promise<void> {
    if (ShellRPCPool.instance) {
      await ShellRPCPool.instance.clear();
      ShellRPCPool.instance = null;
    }
  }

  /**
   * Get pool statistics
   */
  getStats(): {
    size: number;
    locked: number;
    idle: number;
    totalUses: number;
  } {
    let locked = 0;
    let idle = 0;
    let totalUses = 0;

    for (const pooled of this.pool.values()) {
      if (pooled.locked) locked++;
      else idle++;
      totalUses += pooled.useCount;
    }

    return {
      size: this.pool.size,
      locked,
      idle,
      totalUses,
    };
  }
}
```

#### 1.2 Export Pool from Index

**File**: `src/bottles/shell-rpc/index.ts` (additions)

```typescript
// Add to exports
export { ShellRPCPool } from './pool.js';
```

### Phase 2: Fix Synchronous Tool Detection (Day 1-2)

#### 2.1 Create Async Tool Detector

**File**: `src/bottles/shell-rpc/async-tool-detector.ts`

```typescript
/**
 * Asynchronous tool detection with parallel execution
 */
import { exec } from 'node:child_process';
import { promisify } from 'node:util';
import { dirname, sep } from 'node:path';
import { access, constants } from 'node:fs/promises';
import { detectPlatform } from './platform.js';

const execAsync = promisify(exec);

export interface ToolInfo {
  name: string;
  path: string | null;
  version: string | null;
  available: boolean;
}

export interface DetectionOptions {
  parallel?: boolean;
  timeout?: number;
  cache?: boolean;
}

// Cache detection results for the session
const detectionCache = new Map<string, ToolInfo>();

/**
 * Detect a single tool asynchronously
 */
async function detectToolAsync(
  name: string, 
  timeout = 5000
): Promise<ToolInfo> {
  // Check cache first
  if (detectionCache.has(name)) {
    return detectionCache.get(name)!;
  }

  const platform = detectPlatform();
  const command = platform === 'windows' ? 'where' : 'which';

  try {
    // Find tool path
    const { stdout: pathOutput } = await execAsync(`${command} ${name}`, {
      timeout,
      encoding: 'utf8',
    });

    const toolPath = pathOutput.trim().split('\n')[0];
    
    // Get version (best effort)
    let version: string | null = null;
    try {
      const versionCommands = [
        `${name} --version`,
        `${name} -v`,
        `${name} version`,
      ];

      for (const cmd of versionCommands) {
        try {
          const { stdout } = await execAsync(cmd, {
            timeout: 2000,
            encoding: 'utf8',
          });
          
          // Extract version from output
          const versionMatch = stdout.match(/\d+\.\d+\.\d+/);
          if (versionMatch) {
            version = versionMatch[0];
            break;
          }
        } catch {
          // Try next command
        }
      }
    } catch {
      // Version detection failed, tool still available
    }

    const info: ToolInfo = {
      name,
      path: toolPath,
      version,
      available: true,
    };

    // Cache result
    detectionCache.set(name, info);
    return info;

  } catch {
    // Tool not found
    const info: ToolInfo = {
      name,
      path: null,
      version: null,
      available: false,
    };

    // Cache negative result too
    detectionCache.set(name, info);
    return info;
  }
}

/**
 * Detect multiple tools in parallel
 */
export async function detectTools(
  tools: string[],
  options: DetectionOptions = {}
): Promise<Map<string, ToolInfo>> {
  const { parallel = true, timeout = 5000, cache = true } = options;

  if (!cache) {
    detectionCache.clear();
  }

  const results = new Map<string, ToolInfo>();

  if (parallel) {
    // Detect all tools in parallel
    const detectionPromises = tools.map(tool => 
      detectToolAsync(tool, timeout)
        .then(info => results.set(tool, info))
        .catch(() => results.set(tool, {
          name: tool,
          path: null,
          version: null,
          available: false,
        }))
    );

    await Promise.all(detectionPromises);
  } else {
    // Sequential detection (for debugging)
    for (const tool of tools) {
      try {
        const info = await detectToolAsync(tool, timeout);
        results.set(tool, info);
      } catch {
        results.set(tool, {
          name: tool,
          path: null,
          version: null,
          available: false,
        });
      }
    }
  }

  return results;
}

/**
 * Detect Python-specific tools
 */
export async function detectPythonTools(): Promise<Map<string, ToolInfo>> {
  const pythonTools = ['python', 'python3', 'pip', 'pip3', 'uv', 'poetry', 'pipenv'];
  return detectTools(pythonTools);
}

/**
 * Detect Node.js-specific tools
 */
export async function detectNodeTools(): Promise<Map<string, ToolInfo>> {
  const nodeTools = ['node', 'npm', 'yarn', 'pnpm', 'bun'];
  return detectTools(nodeTools);
}

/**
 * Clear detection cache
 */
export function clearDetectionCache(): void {
  detectionCache.clear();
}
```

#### 2.2 Update Existing Tool Detector

**File**: `src/bottles/shell-rpc/tool-detector.ts` (deprecate synchronous)

```typescript
/**
 * @deprecated Use async-tool-detector instead
 * This module uses synchronous operations that block the event loop
 */

// Add deprecation notice to all exports
```

### Phase 3: Fix Timeout Memory Leaks (Day 2)

#### 3.1 Update ShellRPC Cleanup

**File**: `src/bottles/shell-rpc/index.ts` (modifications)

```typescript
// In ShellRPC class, update cleanup method

async cleanup(): Promise<void> {
  if (!this.isAlive) return;

  try {
    // Clear all active timeouts FIRST
    for (const timeout of this.activeTimeouts.values()) {
      timeout.cleanup();
    }
    this.activeTimeouts.clear();

    // Clear command queue
    this.commandQueue.clear();

    // Send exit command if shell is alive
    if (this.shell && this.shell.isAlive()) {
      await this.sendExitCommand();
    }

    // Force kill if still alive
    if (this.shell && this.shell.isAlive()) {
      this.shell.kill('SIGTERM');
      
      // Give it time to die gracefully
      await new Promise(resolve => setTimeout(resolve, 100));
      
      // Force kill if still alive
      if (this.shell.isAlive()) {
        this.shell.kill('SIGKILL');
      }
    }

    // Clean up process manager
    this.processManager.cleanup?.();

    // Clear buffers
    this.outputBuffer = '';
    this.errorBuffer = '';

    // Mark as dead
    this.isAlive = false;
    this.isInitialized = false;

    // Remove all event listeners
    this.removeAllListeners();

  } catch (error) {
    console.error(`[ShellRPC] Cleanup error for ${this.id}:`, error);
  }
}

// Add method to clean specific timeout
private cleanupTimeout(commandId: string): void {
  const timeout = this.activeTimeouts.get(commandId);
  if (timeout) {
    timeout.cleanup();
    this.activeTimeouts.delete(commandId);
  }
}

// Update execute method to ensure timeout cleanup
async execute(command: string, timeout?: number): Promise<CommandResult> {
  const commandId = this.generateCommandId();
  
  try {
    // ... existing execution logic ...
    const result = await this.executeInternal(command, timeout);
    
    // Always cleanup timeout after execution
    this.cleanupTimeout(commandId);
    
    return result;
  } catch (error) {
    // Ensure cleanup on error
    this.cleanupTimeout(commandId);
    throw error;
  }
}
```

### Phase 4: Update Test Utilities (Day 2-3)

#### 4.1 Update Test Environment Creation

**File**: `tests/bottles/integration/common/test-utils.ts` (modifications)

```typescript
import { ShellRPCPool } from '#bottles/shell-rpc/pool';

// Create global pool instance
const shellPool = ShellRPCPool.getInstance({
  maxSize: 5,
  maxIdleTime: 60000,
  reuseStrategy: 'lru',
});

/**
 * Create a test environment with pooled resources
 */
export async function createTestEnvironment(testName: string): Promise<TestEnvironment> {
  const tempId = randomBytes(8).toString('hex');
  const outputDir = resolve(process.cwd(), 'output', 'test-temp');
  const tempDir = join(outputDir, `${testName}-${tempId}`);
  const projectDir = join(tempDir, 'project');

  // Create directories
  await mkdir(tempDir, { recursive: true });
  await mkdir(projectDir, { recursive: true });

  // Get pooled shell instance
  const shellKey = `test-${testName}`;
  const shellRPC = await shellPool.acquire(shellKey, { cwd: projectDir });

  // Create volume controller
  const volumeController = new VolumeController(`test-${testName}-${tempId}`);
  await volumeController.initialize(); // FIX: Actually initialize it!

  const cleanup = async (): Promise<void> => {
    try {
      // Release shell back to pool (don't cleanup)
      shellPool.release(shellKey);
    } catch (error) {
      console.warn(`[TestUtils] Failed to release shell: ${error}`);
    }

    try {
      await volumeController.cleanup();
    } catch (error) {
      console.warn(`[TestUtils] Failed to cleanup volume: ${error}`);
    }

    try {
      // Clean up temp directory
      await rm(tempDir, { recursive: true, force: true });
    } catch (error) {
      console.warn(`[TestUtils] Failed to cleanup temp dir: ${error}`);
    }
  };

  return {
    tempDir,
    projectDir,
    shellRPC,
    volumeController,
    cleanup,
  };
}

/**
 * Global test cleanup - call in afterAll
 */
export async function cleanupTestPool(): Promise<void> {
  await shellPool.clear();
}
```

#### 4.2 Update Test Files

**File**: `tests/bottles/integration/pip/pip-bottle.test.ts` (example update)

```typescript
import { afterAll } from 'vitest';
import { cleanupTestPool } from '../common/test-utils.js';

// ... existing test code ...

// Add global cleanup
afterAll(async () => {
  await cleanupTestPool();
});
```

### Phase 5: Testing & Validation (Day 3-4)

#### 5.1 Create Pool Tests

**File**: `tests/bottles/unit/shell-rpc-pool.test.ts`

```typescript
import { describe, it, expect, beforeAll, afterAll } from 'vitest';
import { ShellRPCPool } from '#bottles/shell-rpc/pool';

describe('ShellRPC Pool', () => {
  let pool: ShellRPCPool;

  beforeAll(() => {
    pool = ShellRPCPool.getInstance({
      maxSize: 3,
      maxIdleTime: 5000,
    });
  });

  afterAll(async () => {
    await pool.clear();
  });

  it('should reuse existing shells', async () => {
    const shell1 = await pool.acquire('test-1');
    pool.release('test-1');
    
    const shell2 = await pool.acquire('test-1');
    expect(shell1).toBe(shell2); // Same instance
  });

  it('should create new shells when needed', async () => {
    const shell1 = await pool.acquire('test-1');
    const shell2 = await pool.acquire('test-2');
    
    expect(shell1).not.toBe(shell2);
  });

  it('should evict least used when full', async () => {
    // Fill pool
    const shell1 = await pool.acquire('test-1');
    pool.release('test-1');
    
    const shell2 = await pool.acquire('test-2');
    pool.release('test-2');
    
    const shell3 = await pool.acquire('test-3');
    pool.release('test-3');
    
    // This should evict test-1 (least recently used)
    const shell4 = await pool.acquire('test-4');
    
    const stats = pool.getStats();
    expect(stats.size).toBe(3);
  });

  it('should clean up idle shells', async () => {
    const shell = await pool.acquire('idle-test');
    pool.release('idle-test');
    
    // Wait for idle timeout
    await new Promise(resolve => setTimeout(resolve, 6000));
    
    const stats = pool.getStats();
    expect(stats.idle).toBe(0);
  });

  it('should handle concurrent acquisitions', async () => {
    const promises = Array.from({ length: 5 }, (_, i) => 
      pool.acquire(`concurrent-${i % 2}`) // Only 2 unique keys
    );
    
    const shells = await Promise.all(promises);
    expect(shells).toHaveLength(5);
  });
});
```

#### 5.2 Create Async Tool Detection Tests

**File**: `tests/bottles/unit/async-tool-detector.test.ts`

```typescript
import { describe, it, expect, beforeEach } from 'vitest';
import { 
  detectTools, 
  detectPythonTools,
  clearDetectionCache 
} from '#bottles/shell-rpc/async-tool-detector';

describe('Async Tool Detector', () => {
  beforeEach(() => {
    clearDetectionCache();
  });

  it('should detect tools in parallel', async () => {
    const start = Date.now();
    const tools = await detectTools(['node', 'npm', 'git']);
    const duration = Date.now() - start;
    
    expect(tools.size).toBe(3);
    expect(duration).toBeLessThan(1000); // Should be fast (parallel)
  });

  it('should cache detection results', async () => {
    const tools1 = await detectTools(['node']);
    const start = Date.now();
    const tools2 = await detectTools(['node']); // Should use cache
    const duration = Date.now() - start;
    
    expect(tools1.get('node')).toEqual(tools2.get('node'));
    expect(duration).toBeLessThan(10); // Cache hit should be instant
  });

  it('should detect Python tools', async () => {
    const tools = await detectPythonTools();
    
    // At least Python should be available in CI
    const python = tools.get('python') || tools.get('python3');
    expect(python?.available).toBe(true);
  });

  it('should handle non-existent tools', async () => {
    const tools = await detectTools(['definitely-not-a-real-tool-xyz']);
    const fakeTool = tools.get('definitely-not-a-real-tool-xyz');
    
    expect(fakeTool).toBeDefined();
    expect(fakeTool?.available).toBe(false);
    expect(fakeTool?.path).toBeNull();
  });
});
```

### Phase 6: Performance Monitoring (Day 4)

#### 6.1 Add Performance Metrics

**File**: `src/bottles/shell-rpc/metrics.ts`

```typescript
/**
 * Performance metrics for Shell-RPC
 */
export class ShellRPCMetrics {
  private static metrics = {
    shellsCreated: 0,
    shellsReused: 0,
    commandsExecuted: 0,
    totalExecutionTime: 0,
    averageExecutionTime: 0,
    poolHits: 0,
    poolMisses: 0,
    timeoutsTriggered: 0,
    memoryLeaks: 0,
  };

  static recordShellCreation(): void {
    this.metrics.shellsCreated++;
    this.metrics.poolMisses++;
  }

  static recordShellReuse(): void {
    this.metrics.shellsReused++;
    this.metrics.poolHits++;
  }

  static recordCommandExecution(duration: number): void {
    this.metrics.commandsExecuted++;
    this.metrics.totalExecutionTime += duration;
    this.metrics.averageExecutionTime = 
      this.metrics.totalExecutionTime / this.metrics.commandsExecuted;
  }

  static recordTimeout(): void {
    this.metrics.timeoutsTriggered++;
  }

  static recordMemoryLeak(): void {
    this.metrics.memoryLeaks++;
  }

  static getMetrics() {
    return {
      ...this.metrics,
      poolHitRate: this.metrics.poolHits / 
        (this.metrics.poolHits + this.metrics.poolMisses) || 0,
    };
  }

  static reset(): void {
    this.metrics = {
      shellsCreated: 0,
      shellsReused: 0,
      commandsExecuted: 0,
      totalExecutionTime: 0,
      averageExecutionTime: 0,
      poolHits: 0,
      poolMisses: 0,
      timeoutsTriggered: 0,
      memoryLeaks: 0,
    };
  }

  static printReport(): void {
    const metrics = this.getMetrics();
    console.log('=== Shell-RPC Performance Report ===');
    console.log(`Shells Created: ${metrics.shellsCreated}`);
    console.log(`Shells Reused: ${metrics.shellsReused}`);
    console.log(`Pool Hit Rate: ${(metrics.poolHitRate * 100).toFixed(2)}%`);
    console.log(`Commands Executed: ${metrics.commandsExecuted}`);
    console.log(`Avg Execution Time: ${metrics.averageExecutionTime.toFixed(2)}ms`);
    console.log(`Timeouts: ${metrics.timeoutsTriggered}`);
    console.log(`Memory Leaks: ${metrics.memoryLeaks}`);
    console.log('===================================');
  }
}
```

#### 6.2 Integration with Pool

Update `ShellRPCPool` to record metrics:

```typescript
// In acquire method
if (existing && !existing.locked) {
  ShellRPCMetrics.recordShellReuse();
  // ...
} else {
  ShellRPCMetrics.recordShellCreation();
  // ...
}
```

## Rollout Plan

### Day 1: Foundation
- [ ] Implement ShellRPCPool class
- [ ] Create async tool detector
- [ ] Write unit tests for pool

### Day 2: Integration
- [ ] Fix timeout cleanup in ShellRPC
- [ ] Update test utilities to use pool
- [ ] Update one test file as proof of concept

### Day 3: Migration
- [ ] Update all integration tests to use pooling
- [ ] Replace synchronous tool detection
- [ ] Add performance metrics

### Day 4: Validation
- [ ] Run full test suite
- [ ] Measure performance improvements
- [ ] Fix any regressions
- [ ] Document changes

## Success Criteria

### Performance
- ‚úÖ Shell initialization overhead < 10ms (from 500-1000ms)
- ‚úÖ Maximum 5 shell processes during tests (from 100+)
- ‚úÖ Pool hit rate > 80%
- ‚úÖ No timeout memory leaks

### Functionality
- ‚úÖ All existing tests pass
- ‚úÖ No race conditions
- ‚úÖ Proper cleanup on test completion
- ‚úÖ CI pipeline runs successfully

### Code Quality
- ‚úÖ 100% async tool detection
- ‚úÖ Zero memory leaks detected
- ‚úÖ Comprehensive error handling
- ‚úÖ Full test coverage for new code

## Risk Mitigation

### Risk: Test Isolation Issues
**Mitigation**: 
- Pool uses separate shells per test name
- Shells are reset between uses
- Critical tests can opt-out of pooling

### Risk: Concurrent Access Problems
**Mitigation**:
- Locking mechanism prevents double-use
- Queue ensures ordered command execution
- Timeout handling per command

### Risk: Resource Exhaustion
**Mitigation**:
- Max pool size limits resource usage
- Automatic eviction of least-used shells
- Periodic cleanup of idle shells

## Monitoring & Rollback

### Monitoring
- Performance metrics logged after each test run
- Pool statistics available via `getStats()`
- Memory usage tracked via process metrics

### Rollback Plan
If issues arise:
1. Disable pooling via environment variable
2. Fall back to creating new shells per test
3. Re-enable gradually with fixes

## Expected Outcomes

### Before
- Test setup: 500-1000ms per test
- Total shells: 100+ during suite
- Memory usage: Growing (leaks)
- CI time: 4.5 minutes

### After
- Test setup: <10ms per test
- Total shells: 5 maximum
- Memory usage: Stable
- CI time: ~2 minutes

### ROI
- **60-80% reduction in test runtime**
- **95% reduction in resource usage**
- **100% elimination of memory leaks**
- **Developer time saved: 2.5 minutes per CI run**

---

**Document Version**: 1.1.0  
**Created**: 2025-08-23  
**Updated**: 2025-08-23 (reordered as Plan 4)  
**Priority**: OPTIMIZATION (can be deferred if needed)  
**Prerequisites**: Plans 1, 2, and 3 MUST be complete  
**Status**: Ready for Implementation AFTER prerequisites